---
title: "template_generation"
output: html_document
---

```{r}
get_igraph_tree <- function(list) {

  letters_used <- unique(unlist(strsplit(list$edge, "-")))
  node_map <- setNames(paste0("node", seq_along(letters_used)), letters_used)
  
  # rename edges
  list$edge <- sapply(list$edge, function(e) {
    parts <- strsplit(e, "-", fixed = TRUE)[[1]]
    paste0(node_map[parts[1]], "-", node_map[parts[2]])
  })

  # set nodes as a,b,c...
  ids <- paste0("node", 1:500)[seq_along(list$node)]
  vtab <- data.frame(
    name    = ids,
    residue = list$node
  )
  names(list$node) <- ids

  # undirected edge
  undirected_mat <- do.call(rbind, strsplit(list$edge, "-", fixed = TRUE))
  colnames(undirected_mat) <- c("v1", "v2")

  ## create a undirected graph
  g0 <- igraph::graph_from_edgelist(undirected_mat, directed = FALSE)

  # from root a to decide direction
  bfs_res <- igraph::bfs(g0, root = "node1", father = TRUE)
  father  <- setNames(igraph::V(g0)$name[bfs_res$father], igraph::V(g0)$name)  # child → father
  father  <- father[!is.na(father)]

  directed_df <- data.frame(
    from = father,                       # parent
    to   = names(father),                # child
    stringsAsFactors = FALSE
  )

  # directed graph
  g <- graph_from_data_frame(
    d        = directed_df,
    directed = TRUE,
    vertices = vtab
  )
  igraph::V(g)$is_root <- igraph::V(g)$name == "node1"

  res_cols <- c("N" = "#1f77b4", "A" = "#800080", "H" = "#2ca02c", "F" = "#d62728", "G" = "#7EC1FF")
  igraph::V(g)$type <- setNames(list$node, ids)[igraph::V(g)$name]
  igraph::V(g)$color <- res_cols[igraph::V(g)$type]
  g
}

show_igraph_tree <- function(g) {
  plot(
    g,
    layout         = igraph::layout_as_tree(g, root = "node1"),
    vertex.label   = igraph::V(g)$type,
    vertex.color   = igraph::V(g)$color,
    vertex.size    = 15,
    edge.arrow.size = 0.6,
    main           = "Glycan topology coloured by residue type"
  )
}

```

```{r}
gd_pglyco <- read.table("data/pGlyco3_related/pGlyco-N-Human.txt", header = FALSE, skip = 1)
gd_pglyco <- gd_pglyco$V1 %>% unique()
sample(gd_pglyco, 1) %>% pGlyco3_to_tree() %>% get_igraph_tree() %>% show_igraph_tree()
```

```{r}
get_igraph_tree <- function(list) {

  letters_used <- unique(unlist(strsplit(list$edge, "-")))
  node_map <- setNames(paste0("node", seq_along(letters_used)), letters_used)
  
  # rename edges
  list$edge <- sapply(list$edge, function(e) {
    parts <- strsplit(e, "-", fixed = TRUE)[[1]]
    paste0(node_map[parts[1]], "-", node_map[parts[2]])
  })

  # set nodes as a,b,c...
  ids <- paste0("node", 1:500)[seq_along(list$node)]
  vtab <- data.frame(
    name    = ids,
    residue = list$node
  )
  names(list$node) <- ids

  # undirected edge
  undirected_mat <- do.call(rbind, strsplit(list$edge, "-", fixed = TRUE))
  colnames(undirected_mat) <- c("v1", "v2")

  ## create a undirected graph
  g0 <- igraph::graph_from_edgelist(undirected_mat, directed = FALSE)

  # from root a to decide direction
  bfs_res <- igraph::bfs(g0, root = "node1", father = TRUE)
  father  <- setNames(igraph::V(g0)$name[bfs_res$father], igraph::V(g0)$name)  # child → father
  father  <- father[!is.na(father)]

  directed_df <- data.frame(
    from = father,                       # parent
    to   = names(father),                # child
    stringsAsFactors = FALSE
  )

  # directed graph
  g <- graph_from_data_frame(
    d        = directed_df,
    directed = TRUE,
    vertices = vtab
  )
  igraph::V(g)$is_root <- igraph::V(g)$name == "node1"

  # res_cols <- c("N" = "#1f77b4", "A" = "#800080", "H" = "#2ca02c", "F" = "#d62728", "G" = "#7EC1FF")
  igraph::V(g)$type <- setNames(list$node, ids)[igraph::V(g)$name]
  # igraph::V(g)$color <- res_cols[igraph::V(g)$type]
  g
}

show_igraph_tree <- function(g) {
  plot(
    g,
    layout         = igraph::layout_as_tree(g, root = "node1"),
    vertex.label   = igraph::V(g)$type,
    # vertex.color   = igraph::V(g)$color,
    vertex.size    = 5,
    edge.arrow.size = 0.6,
    main           = "Glycan topology coloured by residue type"
  )
}
```


```{r}
# annotate_tree
annotate_tree <- function(tree) {
  # ---- 构建邻接表 ----
  edges <- strsplit(tree$edge, "-")
  adj <- list()
  for (e in edges) {
    a <- e[[1]]; b <- e[[2]]
    adj[[a]] <- c(adj[[a]], b)
  }
  
  # ---- 递归计算最长分枝 ----
  get_depth <- function(node) {
    if (is.null(adj[[node]])) return(1)
    return(1 + max(sapply(adj[[node]], get_depth)))
  }
  
  # ---- 递归定义类型 ----
  assign_type <- function(node, prefix) {
    children <- adj[[node]]
    if (is.null(children)) return(NULL)
    
    # 计算每个子节点的分枝长度
    lengths <- sapply(children, get_depth)
    # 按长度从大到小排序（最长的优先）
    order_idx <- order(lengths, decreasing = TRUE)
    children <- children[order_idx]
    
    # 为每个子节点分配类型编号
    for (i in seq_along(children)) {
      child <- children[i]
      child_prefix <- if (prefix == "0") {
        paste0("(", prefix, ")", i)
      } else {
        paste0("(", prefix, ")", i)
      }
      types[[child]] <<- child_prefix
      assign_type(child, child_prefix)
    }
  }
  
  # ---- 初始化 ----
  root <- "a"  # 根节点（假设是 a）
  types <- list()
  types[[root]] <- "0"
  
  # ---- 递归标注 ----
  assign_type(root, "0")
  
  # ---- 输出为 vector ----
  result <- unlist(types)
  return(result)
}
```

```{r}
mat <- c()
for(i in 1:length(gd_pglyco)){
  tree <- gd_pglyco[i] %>% pGlyco3_to_tree()
  # gd_pglyco[10] %>% pGlyco3_to_tree() %>% get_igraph_tree() %>% show_igraph_tree()
  tree$type <- annotate_tree(tree)
  tree$type <- tree$type[order(names(tree$type), decreasing = FALSE)]
  submat <- cbind(tree$node, tree$type)
  mat <- rbind(mat, submat)
}
mat <- unique(mat)
```

```{r}
df <- as.data.frame(mat, stringsAsFactors = FALSE)
colnames(df) <- c("node", "path")
type <- aggregate(node ~ path, df, function(x) paste0(x, collapse =  "|"))
type
```

```{r}
build_graph_from_paths <- function(paths) {
  # 按出现顺序去重，保持稳定次序
  paths <- unique(trimws(paths))

  # 有序集合工具：按第一次出现次序收集 unique
  push_unique <- function(vec, x) {
    for (xi in x) if (!(xi %in% vec)) vec <- c(vec, xi)
    vec
  }

  all_nodes_path <- c("0")       # 用“路径字符串”表示的节点集合，先放根 "0"
  all_edges_path <- character(0) # 用 "parent-child"（均为路径字符串）表示的边集合

  for (p in paths) {
    if (p == "0") {
      # 只有根
      next
    }

    # 取出该路径的所有 ")数字" 令牌，比如 ")1", ")2", ...
    toks <- regmatches(p, gregexpr("\\)\\d+", p))[[1]]

    # 若没有令牌，但不是 "0"，则路径非法；这里直接跳过或 stop 按需
    if (length(toks) == 0) next

    # 从根开始逐层构造完整子路径序列
    subpaths <- "0"
    for (tk in toks) {
      k <- sub("^\\)", "", tk)                    # 去掉前导 ')'
      nxt <- paste0("(", tail(subpaths, 1), ")", k)
      subpaths <- c(subpaths, nxt)
    }

    # 收集节点
    all_nodes_path <- push_unique(all_nodes_path, subpaths)

    # 收集边：相邻子路径构成 parent->child
    if (length(subpaths) >= 2) {
      parent <- subpaths[-length(subpaths)]
      child  <- subpaths[-1]
      new_edges <- paste0(parent, "-", child)
      all_edges_path <- push_unique(all_edges_path, new_edges)
    }
  }

  # ---- 编号：路径 → node1, node2, ...（按首次出现顺序）----
  node_ids <- paste0("node", seq_along(all_nodes_path))
  names(node_ids) <- all_nodes_path  # 路径 -> nodeX 的映射

  # 将边转换为 nodeX-nodeY 形式
  edge <- vapply(all_edges_path, function(e) {
    pr <- strsplit(e, "-", fixed = TRUE)[[1]]
    paste0(node_ids[pr[1]], "-", node_ids[pr[2]])
  }, character(1))

  # 输出：
  # - node：给出 node 名称（如果你要给 igraph 的 “类型/属性”，可以改成相同长度的类型向量；默认根设 N，其余设 H 也行）
  # - edge：nodeX-nodeY
  # - mapping：路径字符串到 nodeX 的映射，便于回查
  list(
    node    = node_ids,   # 这里返回 node 名称，若你想返回类型，可替换为同长度的类型向量
    edge    = edge,
    mapping = node_ids
  )
}

paths <- c(
  "((((0)1)1)1)",
  "((((0)1)1)2)",
  "(((0)1)1)",
  "((0)1)",
  "(0)1",
  "0"
)

graph <- build_graph_from_paths(type$path)
graph %>% get_igraph_tree %>% show_igraph_tree()
```

