#' Compute glycan traits from a parsed glycan tree
#'
#' Combine residue-level composition traits (from
#' [`count_residues()`]) and structural traits (from
#' [`compute_structural_traits()`]) into a unified trait vector.
#'
#' @details
#' This internal function is used by [`annotate_traits_to_gpsm()`].
#' It takes a parsed glycan tree generated by
#' [`wurcs_to_tree()`] or [`pGlyco3_to_tree()`], computes:
#'
#' * monosaccharide composition traits
#' * branching / structural traits
#' * optional user-defined motif counts
#'
#' and returns them as a named list.
#'
#' @param tree A parsed glycan tree with elements:
#'   * `node` — character vector of residue types
#'   * `edge` — vector of parent–child edges
#'
#' @param motifs Optional named list of user-defined glycan motifs,
#'   each supplied in parsed-tree (`node` + `edge`) form.
#'
#' @return A named list of numeric trait values.
#'
#' @keywords internal
#' @noRd
compute_glycan_traits <- function(tree, motifs = NULL) {

  cnt_trait <- count_residues(tree)
  struct_trait <- compute_structural_traits(tree, motifs)

  traits <- c(cnt_trait, struct_trait)
  as.list(traits)
}

#' Append computed glycan traits to a GPSM table
#'
#' Parse each unique glycan structure in a GPSM table, compute its
#' residue and structural traits, and expand the resulting trait
#' columns back to the full GPSM table.
#'
#' @details
#' Workflow:
#'
#' 1. Extract unique glycan structures.
#' 2. Parse each structure using:
#'    * [`wurcs_to_tree()`] for `"decipher"`
#'    * [`pGlyco3_to_tree()`] for `"pGlyco3"`
#' 3. Compute traits using [`compute_glycan_traits()`].
#' 4. Re-map the computed traits to each GPSM and multiply by GPSM counts.
#'
#' Parsing failures are reported via warnings.
#'
#' @param gpsm A GPSM table containing at least:
#'   * `Protein`
#'   * `Peptide`
#'   * `GlycanStructure`
#'   * `count`
#'
#' @param from Character, one of `"decipher"` or `"pGlyco3"`.
#'
#' @param motifs Optional list of user-defined structural motifs.
#'
#' @return A modified GPSM table with appended trait columns.
#'
#' @keywords internal
#' @noRd
annotate_traits_to_gpsm <- function(gpsm, from, motifs) {


  # Split key GPSM columns and other metadata columns
  glycan  <- unique(gpsm$GlycanStructure)

  # Select appropriate glycan-to-tree converter
  if (from == "decipher") {
    get_trait_vector <- function(glycan) {
      glycan_list <- wurcs_to_tree(glycan)
      res_list <- compute_glycan_traits(glycan_list, motifs)
      unlist(res_list)
    }
  } else if (from == "pGlyco3") {
    get_trait_vector <- function(glycan) {
      glycan_list <- pGlyco3_to_tree(glycan)
      res_list <- compute_glycan_traits(glycan_list, motifs)
      unlist(res_list)
    }
  } else {
    warning("`from` must be either 'decipher' or 'pGlyco3'. No traits were computed.")
  }

  # Compute traits for each glycan structure
  traits_list <- pbapply::pblapply(glycan, get_trait_vector)
  traits_columns <- bind_rows(traits_list)

  # add trait to psm matrix
  ind <- match(gpsm$GlycanStructure, glycan)
  traits_add <- gpsm$count * traits_columns[ind,]
  # combine the both
  gpsm <- select(gpsm, -count, -GlycanStructure)
  gpsm <- cbind(gpsm, traits_add)

  gpsm
}

#' Build a SummarizedExperiment of glycan trait matrices
#'
#' Convert a GPSM table into peptide- or protein-level glycan trait matrices
#' and store them in a `SummarizedExperiment`. Each trait becomes an assay
#' matrix whose rows represent peptides or proteins, and whose columns
#' represent individual PSMs.
#'
#' @details
#' The workflow is:
#'
#' 1. Add glycan traits to the GPSM table using
#'    [`annotate_traits_to_gpsm()`].
#' 2. Assign each GPSM a unique `psm_id`.
#' 3. For each trait column, reshape the GPSM table into a wide matrix
#'    (rows = peptides or proteins; columns = PSMs).
#' 4. Assemble all matrices into a `SummarizedExperiment`, with:
#'    * `assays`  — trait × PSM matrices
#'    * `rowData` — peptide/protein identifiers
#'    * `colData` — sample metadata aligned to PSMs
#'
#' This function provides a unified container for downstream analyses such as
#' visualization, differential testing, or tensor conversion.
#'
#' @param gpsm A GPSM table containing at least:
#'   `Protein`, `Peptide`, `GlycanStructure`, `count`, and `File`.
#' @param from Character; glycan format used in the GPSM input.
#'   One of `"decipher"` or `"pGlyco3"`.
#' @param motifs Optional named list of user-defined motif structures
#'   passed to [`compute_glycan_traits()`].
#' @param level Character; summarization level.
#'   Either `"site"` (peptide-level) or `"protein"`.
#' @param meta Data frame of sample metadata with a column `file`
#'   matching `gpsm$File`.
#'
#' @return A `SummarizedExperiment` where each assay is a glycan-trait
#'   matrix (trait × PSM), `rowData` contains peptide/protein names,
#'   and `colData` contains metadata aligned to PSMs.
#'
#' @export
build_trait_se <- function (gpsm, from, motifs = NULL, level, meta) {

  message("adding traits to gpsm matrix")
  gpsm_mat <- annotate_gpsm_with_traits(gpsm, from, motifs)

  if(level == "site") {
    sel <- "Peptide"
  } else if(level == "protein") {
    sel <- "Protein"
  } else {
    warning("`level` must be either 'site' or 'protein'.")
  }

  gpsm_mat$psm_id <- paste0("psm", 1:nrow(gpsm_mat))

  traits <- setdiff(colnames(gpsm_mat), c("Protein", "Peptide", "File", "psm_id"))
  traits_len <- length(traits)
  get_se_level_trait <- function(i) {
    out <- select(gpsm_mat, sel, "psm_id", traits[i])
    out <- pivot_wider(data = out, names_from = psm_id, values_from = traits[i])
    out <- as.data.frame(out)
    row.names(out) <- out[[1]]
    out[,-1]
  }
  message(paste("get", level, "trait matrix list"))
  trait_mat_list <- pbapply::pblapply(1:traits_len, get_se_level_trait)
  names(trait_mat_list) <- traits

  # Summarized Experiments
  ind <- match(gpsm_mat$File, meta$file)
  coldata <- meta[ind, ]
  coldata$psm_id <- gpsm_mat$psm_id

  rowdata <- data.frame(
    level = rownames(trait_mat_list[[1]])
  )

  se <- SummarizedExperiment(
    assays=trait_mat_list,
    rowData = rowdata,
    colData = coldata)
  se
}

